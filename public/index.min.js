class Cube{static render(ctx,cube){Cube.update(cube);Cube.keepInBoundary(ctx,cube);Cube.draw(ctx,cube)}static update(cube){const{position,velocityMultiplier,velocity}=cube;cube.position.x=position.x+velocityMultiplier*velocity.x;cube.position.y=position.y+velocityMultiplier*velocity.y}static draw(ctx,cube){const{color,position,size}=cube;ctx.fillStyle=color;ctx.fillRect(position.x,position.y,size,size)}static changeDirection(target,cube){const angle=Math.atan2(target.y-cube.position.y,target.x-cube.position.x);cube.velocity.x=Math.cos(angle);cube.velocity.y=Math.sin(angle)}static keepInBoundary(ctx,cube){const{size,position}=cube;const xMax=ctx.canvas.width-size;const yMax=ctx.canvas.height-size;if(position.x<0)cube.position.x=0;if(position.x>xMax)cube.position.x=xMax;if(position.y<0)cube.position.y=0;if(position.y>yMax)cube.position.y=yMax}static isCollide(cube1,cube2){return cube1.position.x<cube2.position.x+cube2.size&&cube1.position.x+cube1.size>cube2.position.x&&cube1.position.y<cube2.position.y+cube2.size&&cube1.position.y+cube1.size>cube2.position.y}}class Projectile{static render(ctx,projectile){Projectile.update(projectile);Projectile.draw(ctx,projectile);if(Projectile.isCollideWithBoundary(ctx,projectile)){Projectile.reload(projectile)}}static update(projectile){const{position,velocityMultiplier,velocity}=projectile;projectile.position.x=position.x+velocityMultiplier*velocity.x;projectile.position.y=position.y+velocityMultiplier*velocity.y}static draw(ctx,projectile){const{position,radius,color}=projectile;ctx.beginPath();ctx.arc(position.x,position.y,radius,Math.PI*2,false);ctx.fillStyle=color;ctx.fill()}static fire(projectile,cube){projectile.fired=true;projectile.position.x=cube.position.x+cube.size/2;projectile.position.y=cube.position.y+cube.size/2;projectile.velocity.x=cube.velocity.x;projectile.velocity.y=cube.velocity.y}static reload(projectile){projectile.fired=false;projectile.position.x=0;projectile.position.y=0;projectile.velocity.x=0;projectile.velocity.y=0}static isCollideWithBoundary(ctx,projectile){const{radius,position}=projectile;const xMax=ctx.canvas.width-radius;const yMax=ctx.canvas.height-radius;return position.x<radius||position.x>xMax||position.y<radius||position.y>yMax}static isCollide(projectile,cube){const distX=Math.abs(projectile.position.x-cube.position.x-cube.size/2);const distY=Math.abs(projectile.position.y-cube.position.y-cube.size/2);if(distX>cube.size/2+projectile.radius)return false;if(distY>cube.size/2+projectile.radius)return false;if(distX<=cube.size/2)return true;if(distY<=cube.size/2)return true;const dx=distX-cube.size/2;const dy=distY-cube.size/2;return dx*dx+dy*dy<=projectile.radius*projectile.radius}}class Screen{static fitWindow(ctx){ctx.canvas.width=window.innerWidth;ctx.canvas.height=window.innerHeight}static clear(ctx,hard){ctx.fillStyle=hard?"#000":"rgba(0, 0, 0, 0.1)";ctx.fillRect(0,0,ctx.canvas.width,ctx.canvas.height)}static resize(ctx,state){if(!state){Screen.fitWindow(ctx);return}const temp=Screen.convertToRelativeViewport(ctx,state);Screen.fitWindow(ctx);Screen.convertFromRelativeViewport(ctx,temp)}static convertFromRelativeViewport(ctx,state){return{...state,players:state.players.map(player=>({...player,cube:{...player.cube,size:ctx.canvas.width*player.cube.size,position:{x:ctx.canvas.width*player.cube.position.x,y:ctx.canvas.height*player.cube.position.y}},projectiles:player.projectiles.map(projectile=>({...projectile,radius:ctx.canvas.width*projectile.radius,position:{x:ctx.canvas.width*projectile.position.x,y:ctx.canvas.height*projectile.position.y}}))}))}}static convertToRelativeViewport(ctx,state){return{...state,players:state.players.map(player=>({...player,cube:{...player.cube,size:1/ctx.canvas.width*player.cube.size,position:{x:1/ctx.canvas.width*player.cube.position.x,y:1/ctx.canvas.height*player.cube.position.y}},projectiles:player.projectiles.map(projectile=>({...projectile,radius:1/ctx.canvas.width*projectile.radius,position:{x:1/ctx.canvas.width*projectile.position.x,y:1/ctx.canvas.height*projectile.position.y}}))}))}}}class Panel{static displayPanel(display){const panel=document.querySelector("#panel");panel.style.display=display?"block":"none"}static hideStartButton(){const startButton=document.querySelector("#start-button");startButton.style.display="none"}static displayMessage(display,text){const message=document.querySelector("#message");message.textContent=text;message.style.display=display?"block":"none";message.style.margin=display?"8px":"0px"}static printWinner(winner){return winner?`${winner} won`:"Draw"}}const GameEvents=Object.freeze({CONNECTION:"connection",DISCONNECT:"disconnect",PLAYER_CONNECTED:"player-connected",PLAYER_LIMIT_REACHED:"player-limit-reached",START_GAME:"start-game",FINISH_GAME:"finish-game",UPDATE_GAME_STATE:"update-game-state",GAME_STARTED:"game-started",GAME_FINISHED:"game-finished",GAME_STATE_CHANGED:"game-state-changed",GAME_ALREADY_STARTED:"game-already-started"});const GameStatus=Object.freeze({LOBBY:"lobby",STARTED:"started",FINISHED:"finished"});class Game{constructor(){this.animationId=null;this.playerId=null;this.state=null}connectPlayer(ctx,socket,playerId,state){this.playerId=this.playerId??playerId;this.state=Screen.convertFromRelativeViewport(ctx,state);if(this.state.status===GameStatus.LOBBY){Panel.displayPanel(true)}if(this.state.status===GameStatus.STARTED){Panel.displayMessage(false);Panel.displayPanel(false);this.startRendering(ctx,socket)}if(this.state.status===GameStatus.FINISHED){Panel.displayMessage(true,Panel.printWinner(this.state.winner));Panel.displayPanel(true)}}startGame(ctx,socket,state){this.state=Screen.convertFromRelativeViewport(ctx,state);Panel.displayMessage(false);Panel.displayPanel(false);this.startRendering(ctx,socket)}finishGame(ctx,state){this.state=Screen.convertFromRelativeViewport(ctx,state);Panel.displayMessage(true,Panel.printWinner(this.state.winner));Panel.displayPanel(true);this.stopRendering(ctx)}startRendering(ctx,socket){this.animationId=requestAnimationFrame(()=>this.startRendering(ctx,socket));Screen.clear(ctx,!this.animationId);this.state.players.forEach((currentPlayer,_,players)=>{if(!currentPlayer.alive)return;Cube.render(ctx,currentPlayer.cube);currentPlayer.projectiles.forEach(projectile=>{if(!projectile.fired)return;Projectile.render(ctx,projectile);players.forEach(player=>{if(player.id===projectile.createdBy||!player.alive)return;if(Projectile.isCollide(projectile,player.cube)){player.alive=false;Projectile.reload(projectile);this.checkEndGame(socket);this.updateGameState(ctx,socket)}})});players.forEach(player=>{if(player.id===currentPlayer.id||!player.alive)return;if(Cube.isCollide(currentPlayer.cube,player.cube)){currentPlayer.alive=false;player.alive=false;this.checkEndGame(socket);this.updateGameState(ctx,socket)}})})}stopRendering(ctx){cancelAnimationFrame(this.animationId);Screen.clear(ctx,true)}movePlayerCube(ctx,socket,target){if(!this.playerId||this.state.status!==GameStatus.STARTED)return;const playerIndex=this.state.players.findIndex(({id})=>id===this.playerId);if(playerIndex===-1)return;Cube.changeDirection(target,this.state.players[playerIndex].cube);this.updateGameState(ctx,socket)}fireProjectile(ctx,socket){const playerIndex=this.state.players.findIndex(({id})=>id===this.playerId);if(playerIndex===-1)return;const player=this.state.players[playerIndex];const projectileIndex=player.projectiles.findIndex(({fired})=>!fired);if(projectileIndex===-1)return;Projectile.fire(player.projectiles[projectileIndex],player.cube);this.updateGameState(ctx,socket)}checkEndGame(socket){const alivePlayers=this.state.players.filter(({alive})=>alive);if(alivePlayers.length>=2)return;if(alivePlayers.length===1)this.state.winner=alivePlayers[0].color;if(alivePlayers.length===0)this.state.winner=null;this.state.status=GameStatus.FINISHED;socket.emit(GameEvents.FINISH_GAME,this.state.winner)}acceptServerGameState(ctx,state){if(!this.playerId)return;if(state.players.length===1&&state.status===GameStatus.FINISHED){this.finishGame(ctx,state);return}const playerIndex=state.players.findIndex(({id})=>id===this.playerId);if(playerIndex===-1)return;const player=JSON.stringify(this.state.players[playerIndex]);this.state=Screen.convertFromRelativeViewport(ctx,state);this.state.players[playerIndex]={...JSON.parse(player),alive:this.state.players[playerIndex].alive}}updateGameState(ctx,socket){if(this.state.status!==GameStatus.STARTED)return;socket.emit(GameEvents.UPDATE_GAME_STATE,JSON.stringify({data:{state:Screen.convertToRelativeViewport(ctx,this.state)}}))}}const startButton=document.querySelector("#start-button");const canvas=document.querySelector("canvas");const ctx=canvas.getContext("2d");const socket=io();const game=new Game;Screen.fitWindow(ctx);socket.on(GameEvents.PLAYER_CONNECTED,handlePlayerConnected);socket.on(GameEvents.PLAYER_LIMIT_REACHED,handlePlayerLimitReached);socket.on(GameEvents.GAME_STARTED,handleGameStarted);socket.on(GameEvents.GAME_FINISHED,handleGameFinished);socket.on(GameEvents.GAME_STATE_CHANGED,handleGameStateChanged);socket.on(GameEvents.GAME_ALREADY_STARTED,handleGameAlreadyStarted);window.addEventListener("resize",handleResizeScreen);window.addEventListener("mousemove",handlePlayerMove);window.addEventListener("keydown",handlePlayerAction);startButton.addEventListener("click",handleStartClick);function handlePlayerConnected(payload){const{data}=JSON.parse(payload);game.connectPlayer(ctx,socket,data.playerId,data.state)}function handlePlayerLimitReached(){Screen.displayMessage(true,"There are too many players at the moment");Screen.displayPanel(true);Screen.hideStartButton()}function handleGameStarted(payload){const{data}=JSON.parse(payload);game.startGame(ctx,socket,data.state)}function handleGameFinished(payload){const{data}=JSON.parse(payload);game.finishGame(ctx,data.state)}function handleGameStateChanged(payload){const{data}=JSON.parse(payload);game.acceptServerGameState(ctx,data.state)}function handleGameAlreadyStarted(){Screen.displayMessage(true,"The game is already started");Screen.displayPanel(true);Screen.hideStartButton()}function handleResizeScreen(){Screen.resize(ctx,game.state)}function handlePlayerMove({clientX,clientY}){const target={x:clientX,y:clientY};game.movePlayerCube(ctx,socket,target)}function handlePlayerAction({code}){if(!game.playerId||game.state.status!==GameStatus.STARTED)return;switch(code){case"Space":game.fireProjectile(ctx,socket);break}}function handleStartClick(){socket.emit(GameEvents.START_GAME)}