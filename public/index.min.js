class Cube{static render(ctx,cube){Cube.update(cube);Cube.keepInBoundary(ctx,cube);Cube.draw(ctx,cube)}static update(cube){const{position,velocityMultiplier,velocity}=cube;cube.position.x=position.x+velocityMultiplier*velocity.x;cube.position.y=position.y+velocityMultiplier*velocity.y}static draw(ctx,cube){const{color,position,size}=cube;ctx.fillStyle=color;ctx.fillRect(position.x,position.y,size,size)}static changeDirection(target,cube){const angle=Math.atan2(target.y-cube.position.y,target.x-cube.position.x);cube.velocity.x=Math.cos(angle);cube.velocity.y=Math.sin(angle)}static keepInBoundary(ctx,cube){const{size,position}=cube;const xMax=ctx.canvas.width-size;const yMax=ctx.canvas.height-size;if(position.x<0)cube.position.x=0;if(position.x>xMax)cube.position.x=xMax;if(position.y<0)cube.position.y=0;if(position.y>yMax)cube.position.y=yMax}static isCollide(cube1,cube2){return cube1.position.x<cube2.position.x+cube2.size&&cube1.position.x+cube1.size>cube2.position.x&&cube1.position.y<cube2.position.y+cube2.size&&cube1.position.y+cube1.size>cube2.position.y}}class Projectile{static render(ctx,projectile){Projectile.update(projectile);Projectile.draw(ctx,projectile);if(Projectile.isCollideWithBoundary(ctx,projectile)){Projectile.reload(projectile)}}static update(projectile){const{position,velocityMultiplier,velocity}=projectile;projectile.position.x=position.x+velocityMultiplier*velocity.x;projectile.position.y=position.y+velocityMultiplier*velocity.y}static draw(ctx,projectile){const{position,radius,color}=projectile;ctx.beginPath();ctx.arc(position.x,position.y,radius,Math.PI*2,false);ctx.fillStyle=color;ctx.fill()}static fire(projectile,cube){projectile.fired=true;projectile.position.x=cube.position.x+cube.size/2;projectile.position.y=cube.position.y+cube.size/2;projectile.velocity.x=cube.velocity.x;projectile.velocity.y=cube.velocity.y}static reload(projectile){projectile.fired=false;projectile.position.x=0;projectile.position.y=0;projectile.velocity.x=0;projectile.velocity.y=0}static isCollideWithBoundary(ctx,projectile){const{radius,position}=projectile;const xMax=ctx.canvas.width-radius;const yMax=ctx.canvas.height-radius;return position.x<radius||position.x>xMax||position.y<radius||position.y>yMax}static isCollide(projectile,cube){const distX=Math.abs(projectile.position.x-cube.position.x-cube.size/2);const distY=Math.abs(projectile.position.y-cube.position.y-cube.size/2);if(distX>cube.size/2+projectile.radius)return false;if(distY>cube.size/2+projectile.radius)return false;if(distX<=cube.size/2)return true;if(distY<=cube.size/2)return true;const dx=distX-cube.size/2;const dy=distY-cube.size/2;return dx*dx+dy*dy<=projectile.radius*projectile.radius}}const GameEvents=Object.freeze({USER_CONNECTED:"user-connected",TOO_MANY_PLAYERS:"too-many-players",GAME_ALREADY_STARTED:"game-already-started",GAME_STATE_UPDATE:"game-state-update",GAME_STATE_CHANGED:"game-state-changed"});const GameStatus=Object.freeze({LOBBY:"lobby",STARTED:"started",FINISHED:"finished"});class GameScreen{static setup(ctx){ctx.canvas.width=window.innerWidth;ctx.canvas.height=window.innerHeight}static clear(ctx,full){ctx.fillStyle=full?"#000":"rgba(0, 0, 0, 0.1)";ctx.fillRect(0,0,ctx.canvas.width,ctx.canvas.height)}static resize(ctx,state){if(!state){ctx.canvas.width=window.innerWidth;ctx.canvas.height=window.innerHeight;return null}const temp=GameScreen.convertToRelativeViewport(ctx,state);ctx.canvas.width=window.innerWidth;ctx.canvas.height=window.innerHeight;return GameScreen.convertFromRelativeViewport(ctx,temp)}static convertFromRelativeViewport(ctx,state){return{...state,players:state.players.map(player=>({...player,cube:{...player.cube,size:ctx.canvas.width*player.cube.size,position:{x:ctx.canvas.width*player.cube.position.x,y:ctx.canvas.height*player.cube.position.y}},projectiles:player.projectiles.map(projectile=>({...projectile,radius:ctx.canvas.width*projectile.radius,position:{x:ctx.canvas.width*projectile.position.x,y:ctx.canvas.height*projectile.position.y}}))}))}}static convertToRelativeViewport(ctx,state){return{...state,players:state.players.map(player=>({...player,cube:{...player.cube,size:1/ctx.canvas.width*player.cube.size,position:{x:1/ctx.canvas.width*player.cube.position.x,y:1/ctx.canvas.height*player.cube.position.y}},projectiles:player.projectiles.map(projectile=>({...projectile,radius:1/ctx.canvas.width*projectile.radius,position:{x:1/ctx.canvas.width*projectile.position.x,y:1/ctx.canvas.height*projectile.position.y}}))}))}}static displayPanel(display){const panel=document.querySelector("#panel");panel.style.display=display?"block":"none"}static hideStartButton(){const startButton=document.querySelector("#start-button");startButton.style.display="none"}static displayMessage(display,text){const message=document.querySelector("#message");message.textContent=text;message.style.display=display?"block":"none";message.style.margin=display?"8px":"0px"}static printWinner(winner){return winner?`${winner} won`:"Draw"}}const startButton=document.querySelector("#start-button");const canvas=document.querySelector("canvas");const ctx=canvas.getContext("2d");const socket=io();let animationId=null;let playerId=null;let state=null;function startGame(){state.status=GameStatus.STARTED;updateGameState();GameScreen.displayMessage(false);GameScreen.displayPanel(false);startRendering()}function startRendering(){animationId=requestAnimationFrame(startRendering);GameScreen.clear(ctx,!animationId);state.players.forEach((currentPlayer,_,players)=>{if(!currentPlayer.alive)return;Cube.render(ctx,currentPlayer.cube);currentPlayer.projectiles.forEach(projectile=>{if(!projectile.fired)return;Projectile.render(ctx,projectile);players.forEach(player=>{if(player.id===projectile.createdBy||!player.alive)return;if(Projectile.isCollide(projectile,player.cube)){player.alive=false;Projectile.reload(projectile);checkEndGame();updateGameState()}})});players.forEach(player=>{if(player.id===currentPlayer.id||!player.alive)return;if(Cube.isCollide(currentPlayer.cube,player.cube)){currentPlayer.alive=false;player.alive=false;checkEndGame();updateGameState()}})})}function stopRendering(){cancelAnimationFrame(animationId);GameScreen.clear(ctx,true)}function updateGameState(){socket.emit(GameEvents.GAME_STATE_UPDATE,JSON.stringify({data:{state:GameScreen.convertToRelativeViewport(ctx,state)}}))}function checkEndGame(){const alivePlayers=state.players.filter(player=>player.alive);if(alivePlayers.length>=2)return;if(alivePlayers.length===1)state.winner=alivePlayers[0].color;if(alivePlayers.length===0)state.winner=null;state.status=GameStatus.FINISHED;GameScreen.displayMessage(true,GameScreen.printWinner(state.winner));GameScreen.displayPanel(true);stopRendering()}function fireProjectile(){const playerIndex=state.players.findIndex(({id})=>id===playerId);if(playerIndex===-1)return;const projectileIndex=state.players[playerIndex].projectiles.findIndex(({fired})=>!fired);if(projectileIndex===-1)return;const projectile=state.players[playerIndex].projectiles[projectileIndex];const cube=state.players[playerIndex].cube;Projectile.fire(projectile,cube);updateGameState()}function handleUserConnected(payload){const{data}=JSON.parse(payload);playerId=data.playerId;state=GameScreen.convertFromRelativeViewport(ctx,data.state);if(state.status===GameStatus.LOBBY){GameScreen.displayPanel(true)}if(state.status===GameStatus.STARTED){GameScreen.displayMessage(false);GameScreen.displayPanel(false);startRendering()}if(state.status===GameStatus.FINISHED){GameScreen.displayMessage(true,GameScreen.printWinner(state.winner));GameScreen.displayPanel(true)}}function handleTooManyPlayers(){GameScreen.displayMessage(true,"There are too many players at the moment");GameScreen.displayPanel(true);GameScreen.hideStartButton()}function handleGameAlreadyStarted(){GameScreen.displayMessage(true,"The game is already started");GameScreen.displayPanel(true);GameScreen.hideStartButton()}function handleGameStateChanged(payload){if(!playerId)return;const{data}=JSON.parse(payload);const startedInServer=data.state.status===GameStatus.STARTED;const startedInLocal=state.status===GameStatus.STARTED;const finishedInServer=data.state.status===GameStatus.FINISHED;const finishedInLocal=state.status===GameStatus.FINISHED;if(startedInServer&&!startedInLocal){state=GameScreen.convertFromRelativeViewport(ctx,data.state);GameScreen.displayMessage(false);GameScreen.displayPanel(false);startRendering();return}if(finishedInServer&&!finishedInLocal){GameScreen.displayMessage(true,GameScreen.printWinner(data.state.winner));GameScreen.displayPanel(true);stopRendering()}const playerIndex=data.state.players.findIndex(({id})=>id===playerId);if(playerIndex===-1)return;const player=JSON.stringify({...state.players[playerIndex]});state=GameScreen.convertFromRelativeViewport(ctx,data.state);state.players[playerIndex]={...JSON.parse(player),alive:data.state.players[playerIndex].alive}}function handleResize(){state=GameScreen.resize(ctx,state)}function handlePlayerMove({clientX,clientY}){if(!playerId||state.status!==GameStatus.STARTED)return;const playerIndex=state.players.findIndex(({id})=>id===playerId);if(playerIndex===-1)return;const target={x:clientX,y:clientY};const cube=state.players[playerIndex].cube;Cube.changeDirection(target,cube);updateGameState()}function handlePlayerAction({code}){if(!playerId||state.status!==GameStatus.STARTED)return;switch(code){case"Space":fireProjectile();break}}GameScreen.setup(ctx);socket.on(GameEvents.USER_CONNECTED,handleUserConnected);socket.on(GameEvents.TOO_MANY_PLAYERS,handleTooManyPlayers);socket.on(GameEvents.GAME_ALREADY_STARTED,handleGameAlreadyStarted);socket.on(GameEvents.GAME_STATE_CHANGED,handleGameStateChanged);addEventListener("resize",handleResize);addEventListener("mousemove",handlePlayerMove);addEventListener("keydown",handlePlayerAction);startButton.addEventListener("click",()=>startGame(socket));